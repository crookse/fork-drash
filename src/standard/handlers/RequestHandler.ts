/**
 * Drash - A micro HTTP framework for JavaScript and TypeScript systems.
 * Copyright (C) 2023  Drash authors. The Drash authors are listed in the
 * AUTHORS file at <https://github.com/drashland/drash/AUTHORS>. This notice
 * applies to Drash version 3.X.X and any later version.
 *
 * This file is part of Drash. See <https://github.com/drashland/drash>.
 *
 * Drash is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Drash is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Drash. If not, see <https://www.gnu.org/licenses/>.
 */

// Imports > Core
import { HTTPError } from "../errors/HTTPError.ts";
import type { IBuilder } from "../../core/interfaces/IBuilder.ts";
import type { IHandler } from "../../core/interfaces/IHandler.ts";

// Imports > Standard
import {
  AbstractRequestHandler,
  type InputRequest,
} from "./AbstractRequestHandler.ts";
import { GroupConsoleLogger } from "../log/GroupConsoleLogger.ts";
import type { LogGroup } from "../log/AbstractLogGroup.ts";
import type { Logger } from "../log/Logger.ts";

class Builder implements IBuilder {
  protected constructor_args: CtorParams = {};

  /**
   * Set the logger the request handler will use.
   * @param handler
   * @returns This instance so you can chain more methods.
   */
  public logger(logger?: LogGroup): this {
    this.constructor_args.logger = logger;
    return this;
  }

  /**
   * Set the request validator the request handler will use.
   * @param handler
   * @returns This instance so you can chain more methods.
   */
  public requestValidator(handler?: IHandler): this {
    this.constructor_args.request_validator = handler;
    return this;
  }

  public build<I extends InputRequest, O>(): RequestHandler<I, O> {
    return new RequestHandler<I, O>(this.constructor_args);
  }
}

type CtorParams = {
  request_validator?: IHandler;
  logger?: LogGroup;
};

export class RequestHandler<
  I extends InputRequest,
  O,
> extends AbstractRequestHandler<I, O> {
  static Builder = Builder;

  #logger: Logger = GroupConsoleLogger.create("RequestHandler");

  /**
   * A handler that validates this handler's incoming request.
   */
  #request_validator?: IHandler;

  constructor(options: CtorParams) {
    super();

    if (options.request_validator) {
      this.#request_validator = options.request_validator;
    }

    if (options.logger) {
      this.#logger = options.logger;
    }
  }

  static builder(): Builder {
    return new Builder();
  }

  /**
   * Handle the incoming `Request` by creating a context object for it and
   * passing that context through the chain of handlers. Each handler in the
   * chain can handle the request as they deem fit or pass it to the next
   * handler in the chain. The last handler returns the context object back to
   * this method. Once the context object is received back in this method, the
   * response builder in the context object is used to build the `Response`
   * object that gets passed to the caller.
   * @param incomingRequest The incoming `Request` object that is handled by the
   * chain of handlers.
   * @returns A `Response` for the caller to further process.
   */
  public handle(request: I): Promise<O> {
    this.#logger.debug(`Request received - typeof: {}`, typeof request);

    return Promise
      .resolve()
      .then(() => this.validate(request))
      .then(() => this.sendToNextHandler(request));
  }

  // /**
  //  * Respond to the caller.
  //  * @param response The response generated by the next handler(s).
  //  * @returns The response (if it exists).
  //  * @throws An {@link HTTPError} if a response was not generated.
  //  */
  // protected respond(response: O): O {
  //   this.#logger.debug("Returning response to caller");
  //   return response;
  // }

  /**
   * Send the request to the next handler.
   * @param response
   * @returns
   */
  protected sendToNextHandler(request: I): Promise<O> {
    this.#logger.debug(`Sending request to next handler`);
    return super.handle(request);
  }

  /**
   * Validate the given `request`.
   * @param request The request in question.
   */
  protected validate(request: unknown): void {
    if (this.#request_validator) {
      this.#request_validator.handle(request);
    }
  }
}

// FILE MARKER - PUBLIC API ////////////////////////////////////////////////////

export { AbstractRequestHandler, type Builder, type CtorParams };
